package com.fames.protokit.plugin.codegen

import com.google.protobuf.DescriptorProtos
import com.google.protobuf.DescriptorProtos.FileDescriptorProto
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.buildCodeBlock
import java.io.File

class ProtoKitCodegen(
    private val fileDescriptor: FileDescriptorProto,
    private val outputDir: File
) {
    private val packageName = fileDescriptor.`package`

    fun generate() {
        val fileName = fileDescriptor.name.substringBeforeLast('.') + "Protokit.kt"
        val fileSpecBuilder = FileSpec.builder(packageName, fileName)
            .addFileComment("Generated by ProtoKit. DO NOT EDIT.")
            .indent("    ")

        fileDescriptor.messageTypeList.forEach { fileSpecBuilder.addType(generateMessage(it)) }
        fileDescriptor.serviceList.forEach { service ->
            val (iface, client) = generateService(service)
            fileSpecBuilder.addType(iface)
            fileSpecBuilder.addType(client)
        }

        fileSpecBuilder.build().writeTo(outputDir)
    }

    private fun generateMessage(messageDescriptor: DescriptorProtos.DescriptorProto): TypeSpec {
        val messageClassName = ClassName(packageName, messageDescriptor.name)
        val messageBuilder = TypeSpec.classBuilder(messageClassName).addModifiers(KModifier.DATA)
        val constructorBuilder = FunSpec.constructorBuilder()

        messageDescriptor.fieldList.forEach { field ->
            val fieldName = field.name
            val fieldType = mapProtoTypeToKotlin(field)
            constructorBuilder.addParameter(fieldName, fieldType)
            messageBuilder.addProperty(PropertySpec.builder(fieldName, fieldType).initializer(fieldName).build())
        }
        messageBuilder.primaryConstructor(constructorBuilder.build())

        // Add encode() and decode() methods
        messageBuilder.addFunction(generateEncodeMethod(messageDescriptor))
        messageBuilder.addType(generateDecodeCompanion(messageDescriptor))

        return messageBuilder.build()
    }

    private fun generateEncodeMethod(messageDescriptor: DescriptorProtos.DescriptorProto): FunSpec {
        val code = buildCodeBlock {
            addStatement("val writer = %T()", PROTO_WRITER_CLASS_NAME)
            messageDescriptor.fieldList.forEach { field ->
                add(generateFieldWriteCode(field))
            }
            addStatement("return writer.toByteArray()")
        }
        return FunSpec.builder("encode")
            .addModifiers(KModifier.INTERNAL)
            .returns(ByteArray::class)
            .addCode(code)
            .build()
    }

    private fun generateDecodeCompanion(messageDescriptor: DescriptorProtos.DescriptorProto): TypeSpec {
        val messageClassName = ClassName(packageName, messageDescriptor.name)
        val code = buildCodeBlock {
            messageDescriptor.fieldList.forEach { field ->
                val fieldType = mapProtoTypeToKotlin(field, isMutable = true)
                val defaultValue = protoDefault(field)
                addStatement("var %L: %T = %L", field.name, fieldType, defaultValue)
            }
            addStatement("reader.forEachTag { tag ->")
            indent()
            addStatement("when (tag) {")
            messageDescriptor.fieldList.forEach { field ->
                addStatement("%L -> %L = %L", field.number, field.name, generateFieldReadCode(field))
            }
            addStatement("else -> reader.skipField()")
            addStatement("}")
            unindent()
            addStatement("}")

            val constructorArgs = messageDescriptor.fieldList.joinToString(",\n") { it.name }
            addStatement("return %T(\n%L\n)", messageClassName, constructorArgs)
        }

        val companion = TypeSpec.companionObjectBuilder()
            .addFunction(
                FunSpec.builder("decode")
                    .addModifiers(KModifier.INTERNAL)
                    .addParameter("bytes", ByteArray::class)
                    .returns(messageClassName)
                    .addStatement("return decode(%T(bytes))", PROTO_READER_CLASS_NAME)
                    .build()
            )
            .addFunction(
                FunSpec.builder("decode")
                    .addModifiers(KModifier.INTERNAL)
                    .addParameter("reader", PROTO_READER_CLASS_NAME)
                    .returns(messageClassName)
                    .addCode(code)
                    .build()
            )
            .build()
        return companion
    }

    private fun generateService(serviceDescriptor: DescriptorProtos.ServiceDescriptorProto): Pair<TypeSpec, TypeSpec> {
        val serviceName = serviceDescriptor.name
        val serviceInterfaceName = ClassName(packageName, serviceName)

        val interfaceBuilder = TypeSpec.interfaceBuilder(serviceInterfaceName)
            .addKdoc("Generated gRPC service interface for %L.", serviceName)

        val clientName = "${serviceName}Client"
        val clientBuilder = TypeSpec.classBuilder(clientName)
            .addSuperinterface(serviceInterfaceName)
            .primaryConstructor(FunSpec.constructorBuilder().addParameter("client", PROTO_CLIENT_CLASS_NAME).build())
            .addProperty(PropertySpec.builder("client", PROTO_CLIENT_CLASS_NAME, KModifier.PRIVATE).initializer("client").build())

        serviceDescriptor.methodList.forEach { methodDescriptor ->
            val methodName = methodDescriptor.name.lowercaseFirst()
            val requestType = ClassName(packageName, methodDescriptor.inputType.split('.').last())
            val responseType = ClassName(packageName, methodDescriptor.outputType.split('.').last())
            val parameterizedResponseType = RESPONSE_CLASS_NAME.parameterizedBy(responseType)

            interfaceBuilder.addFunction(
                FunSpec.builder(methodName).addModifiers(KModifier.SUSPEND, KModifier.ABSTRACT)
                    .addParameter("request", requestType).returns(parameterizedResponseType).build()
            )

            val methodBody = buildCodeBlock {
                add("return client.unary(\n")
                indent()
                add("method = \"/%L.%L/%L\",\n", packageName, serviceName, methodDescriptor.name)
                add("request = request,\n")
                add("encoder = { it.encode() },\n")
                add("decoder = { bytes -> %T.decode(bytes) }\n", responseType)
                unindent()
                add(")")
            }

            clientBuilder.addFunction(
                FunSpec.builder(methodName).addModifiers(KModifier.SUSPEND, KModifier.OVERRIDE)
                    .addParameter("request", requestType).returns(parameterizedResponseType).addCode(methodBody).build()
            )
        }

        return Pair(interfaceBuilder.build(), clientBuilder.build())
    }

    private fun mapProtoTypeToKotlin(field: DescriptorProtos.FieldDescriptorProto, isMutable: Boolean = false): TypeName {
        val type = when (field.type) {
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_DOUBLE -> Double::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FLOAT -> Float::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED64 -> Long::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED32 -> Int::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BOOL -> Boolean::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_STRING -> String::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BYTES -> ByteArray::class.asTypeName()
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_MESSAGE, DescriptorProtos.FieldDescriptorProto.Type.TYPE_ENUM -> ClassName(packageName, field.typeName.split('.').last())
            else -> throw IllegalArgumentException("Unsupported field type: ${field.type}")
        }

        if (field.label == DescriptorProtos.FieldDescriptorProto.Label.LABEL_REPEATED) {
            val listType = if (isMutable) MUTABLE_LIST_CLASS_NAME else LIST_CLASS_NAME
            return listType.parameterizedBy(type)
        }
        return type
    }
    
    private fun protoDefault(field: DescriptorProtos.FieldDescriptorProto): String {
        if (field.label == DescriptorProtos.FieldDescriptorProto.Label.LABEL_REPEATED) return "mutableListOf()"
        return when (field.type) {
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_DOUBLE -> "0.0"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FLOAT -> "0f"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT64,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED64 -> "0L"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT32,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED32 -> "0"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BOOL -> "false"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_STRING -> "\"\""
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BYTES -> "ByteArray(0)"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_MESSAGE -> "${field.typeName.split('.').last()}.decode(byteArrayOf()) // TODO: default instance"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_ENUM -> "${field.typeName.split('.').last()}.values().first() // TODO: default enum"
            else -> "null"
        }
    }

    private fun generateFieldWriteCode(field: DescriptorProtos.FieldDescriptorProto): CodeBlock {
        val writerMethod = when (field.type) {
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_STRING -> "writeString"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BYTES -> "writeBytes"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BOOL -> "writeBool"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT32,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED32 -> "writeInt32"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT64,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED64 -> "writeInt64"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FLOAT -> "writeFloat"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_DOUBLE -> "writeDouble"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_MESSAGE -> "writeObject"
            else -> "// TODO: Write support for ${field.type}"
        }
        val fieldName = field.name
        val fieldNumber = field.number

        if (field.label == DescriptorProtos.FieldDescriptorProto.Label.LABEL_REPEATED) {
            return buildCodeBlock { addStatement("%L.forEach { writer.%L(%L, it) }", fieldName, writerMethod, fieldNumber) }
        } else {
            if (field.type == DescriptorProtos.FieldDescriptorProto.Type.TYPE_MESSAGE) {
                return buildCodeBlock { addStatement("writer.%L(%L) { %L.encode() }", writerMethod, fieldNumber, fieldName) }
            }
            return buildCodeBlock { addStatement("writer.%L(%L, %L)", writerMethod, fieldNumber, fieldName) }
        }
    }
    
    private fun generateFieldReadCode(field: DescriptorProtos.FieldDescriptorProto): CodeBlock {
        val readerMethod = when (field.type) {
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_STRING -> "reader.readString()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BYTES -> "reader.readBytes()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_BOOL -> "reader.readBool()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT32,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED32, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED32 -> "reader.readInt32()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_INT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_UINT64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SINT64,
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FIXED64, DescriptorProtos.FieldDescriptorProto.Type.TYPE_SFIXED64 -> "reader.readInt64()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_FLOAT -> "reader.readFloat()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_DOUBLE -> "reader.readDouble()"
            DescriptorProtos.FieldDescriptorProto.Type.TYPE_MESSAGE -> "%T.decode(reader.readBytes())".format(ClassName(packageName, field.typeName.split('.').last()))
            else -> "// TODO: Read support for ${field.type}"
        }
        return CodeBlock.of(readerMethod)
    }

    private fun String.lowercaseFirst(): String {
        return if (this.isNotEmpty()) this[0].lowercaseChar() + this.substring(1) else this
    }

    companion object {
        private val PROTO_CLIENT_CLASS_NAME = ClassName("com.fames.protokit.sdk", "ProtoClient")
        private val RESPONSE_CLASS_NAME = ClassName("com.fames.protokit.sdk.models", "Response")
        private val PROTO_WRITER_CLASS_NAME = ClassName("com.fames.protokit.core.io", "ProtoWriter")
        private val PROTO_READER_CLASS_NAME = ClassName("com.fames.protokit.core.io", "ProtoReader")
        private val LIST_CLASS_NAME = ClassName("kotlin.collections", "List")
        private val MUTABLE_LIST_CLASS_NAME = ClassName("kotlin.collections", "MutableList")
    }
}
